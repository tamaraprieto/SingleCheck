#!/bin/bash
#SBATCH -N 1
#SBATCH -n 1
#SBATCH --mail-user tamara.prieto.fernandez@gmail.com
#SBATCH --mail-type FAIL
#SBATCH --cpus-per-task 3
#SBATCH -t 10:00:00
#SBATCH --mem 60G

############################################################################
#                        USAGE                                             #
############################################################################
	usage="
	$(basename "$0") [options] <in.bam|in.fastq.gz> <in2.fastq.gz>
	
	options:
	    -h  show this help text
	    -w  set the window size for gini index, coefficient of variation and MAD (default: 10000)
            -i  set increment/delta for autocorrelation (default: 1000)
            -t  number of threads
            -f  flag of the reads to filter out
            -q  mapping quality of the reads to analize 
	    -d  regular expresion  matching the lines starting by chromosome names which are diploid (default: \"^[1-9|X]\")
        Note: the bam file must be indexed and fastq files must be .gz compressed.
	"

	WSIZE=10000000
	DELTA=1000
	#SUFFIX="X.filtered"
	FLAGTOFILTEROUT=772
	THREADS=3
	MAPQUAL=20
        DIPLOID_REGEX="^[1-9|X]"

	while getopts ':hw:i:f:t:q:d:r::' option; do
	  case "$option" in
	    h) echo "$usage"
	       exit
	       ;;
	    w) WSIZE=$OPTARG
               isanum=^[0-9]+$                    
               if [[ ! $WSIZE =~ $isanum ]] || [[ $WSIZE -eq 0 ]]; then   
               printf "\nError: -w must be a positive whole number higher than 0\n"
	       echo "$usage" >&2 
               exit 1
	       fi
	       ;;
            i) DELTA=$OPTARG
               isanum=^[0-9]+$
               if [[ ! $DELTA =~ $isanum ]] || [[ $DELTA -eq 0 ]]; then
               printf "\nError: -a must be a positive whole number higher than 0\n"
               echo "$usage" >&2
               exit 1
               fi
               ;;
            f) FLAGTOFILTEROUT=$OPTARG
               ;;
            t) THREADS=$OPTARG
               ;;
            q) MAPQUAL=$OPTARG
               isanum=^[0-9]+$
               if [[ ! $MAPQUAL =~ $isanum ]]; then
               printf "\nError: -q must be a positive whole number\n"
               echo "$usage" >&2
               exit 1
               fi
               ;;
            d) DIPLOID_REGEX=$OPTARG
               ;;
            r) REFERENCE=$OPTARG
               ;;
	    :) printf "missing argument for -%s\n" "$OPTARG" >&2
	       echo "$usage" >&2
	       exit 1
	       ;;
	   \?) printf "illegal option: -%s\n" "$OPTARG" >&2
	       echo "$usage" >&2
	       exit 1
	       ;;
	  esac
	done
	shift $((OPTIND - 1))


if [ "$#" -gt 2 ]; then
    printf "\nIncorrect number of arguments\n" >&2
    echo "$usage" >&2
    exit 1
fi

# mandatory arguments
if [ "$#" -eq 1 ]; then
	FILE="$1"
        if [[ "$FILE" != *.bam ]] && [[ "$FILE" != *.fastq.gz ]]; then
            printf "\nFile extension must be \'.bam\' or \'.fastq.gz\'\n" >&2
            echo "$usage" >&2
            exit 1
        fi

	if [ ! -f "$FILE" ]; then
	    echo ""
	    echo "$FILE does not exists"
	    echo ""
	    echo "$usage" >&2
	    exit 1
	fi
	if [[ "$FILE" == *.bam ]];then
	    METHOD="Aligned"
        else
	    METHOD="Single-end"
            FASTQ1=$FILE
            FASTQ2=""
	fi
	
	NAME=$(echo $FILE | sed 's/.bam//' | sed 's/.fastq.gz//' )
	
elif [ "$#" -eq 2 ]; then 
	FASTQ1="$1"
	FASTQ2="$2"
	METHOD="Paired-end"
	if [[ "$FASTQ1" != *_1.fastq.gz ]] || [[ "$FASTQ2" != *_2.fastq.gz ]];then
	    printf "\nPaired-end fastq files must be named as \'_1.fastq.gz\' and \'_2.fastq.gz\'\n" >&2
	    echo "$usage" >&2
	    exit 1
	elif [ ! -f "$FASTQ2" ] || [ ! -f "$FASTQ1" ]; then
	    echo ""
	    echo "One or both fastq file do not exist"
	    echo ""
	    echo "$usage" >&2
	    exit 1
	fi
	NAME=$(echo $FASTQ1 | sed 's/_1.fastq.gz//')
else
	exit 1
fi

############################################################################
#                        SET UP VARIABLES                                  #
############################################################################

if [ -n "$SLURM_JOB_ID" ] && [ "$SLURM_JOB_ID" -eq "$SLURM_JOB_ID" ]
then
    SCRIPT=$(scontrol show job $SLURM_JOBID | awk -F= '/Command=/{print $2}' | awk '{print $1}')
    SCRIPTDIR=$(dirname $SCRIPT)
else
    SCRIPTDIR=$(pwd -P)
fi

printf "\n\tSingleCheck -w %s -i %s -f %s -t %s -q %s %s\n\n" "$WSIZE" "$DELTA" "$FLAGTOFILTEROUT" "$THREADS" "$MAPQUAL" "$FILE"

############################################################################
#                        LOAD MODULES                                      #
############################################################################
	
	module purge 2> /dev/null
	module load samtools/1.10 2> /dev/null
	module load gcc/6.4.0 R/3.6.3 2> /dev/null
        module load miniconda3/4.8.2 2> /dev/null
        module load gcccore/6.4.0 bedtools/2.28.0 2> /dev/null
        module load gcc/6.4.0 bwa/0.7.17 2> /dev/null
        source activate /mnt/netapp1/posadalab/APPS/CommonCondaEnvironments/mosdepth 2> /dev/null

# ///////// CONDA ENVIRONMENTS MISSING, CREATE A SINGLE ONE

############################################################################
#                        MAP READS IF INPUT IS A FASTQ FILE                #
############################################################################

if [ "$METHOD" == "Paired-end" ] || [ "$METHOD" == "Single-end" ]; then
        fai_index=$(echo $REFERENCE | sed 's/.fa/.fai/')
        bwa_index=$(echo $REFERENCE | sed 's/.fa/.fa.ann/')
        if [ -z $REFERENCE ] || [ ! -f $REFERENCE ] || [ ! -f $fai_index ] || [ ! -f $bwa_index ];then
             printf "\nCheck that your reference exists and it has been properly indexed\n" >&2
             echo "$usage" >&2
             exit 1
        fi
	bwa mem -t $THREADS $REFERENCE \
		$FASTQ1 $FASTQ2 | \
		samtools sort -@$THREADS \
		-o ${NAME}.bam -
        samtools index ${NAME}.bam
fi

############################################################################
#                        CALCULATE COVERAGE BIAS                           #
############################################################################


if [ ! -f ${NAME}.bam.bai ]; then
	printf "\nError: your BAM file must be indexed\n" >&2
        exit 1
fi

#if [[ ! -f ${NAME}.${WSIZE}.regions.bed.gz ]]
#then
echo "> Running mosdepth"
        # the number of floats I need for mosdepth depends on the window size
	# wc -c gives an extra character (\n). window size of 100 (3 chars) -> minimum coverage will be 0.01 (2 decs)
        precision=$(echo $WSIZE | wc -c | awk '{print $1-2}')

        # --fast-mode dont look at internal cigar operations or correct mate overlaps (recommended for most use-cases). Avoids the extra calculations of mate pair overlap and cigar operations
        # 772 flag: exclude read unmapped, not primary alignment, read fails platform/vendor quality checks
        MOSDEPTH_PRECISION=${precision} mosdepth \
                -t $THREADS \
                --fast-mode \
                --by $WSIZE \
                --flag $FLAGTOFILTEROUT \
                --mapq $MAPQUAL \
                ${NAME}.${WSIZE} \
                ${NAME}.bam
        # Output .regions.bed.gz contains mean base depth per window
	rm ${NAME}.${WSIZE}.mosdepth* # remove extra files created by mosdepth

#fi
conda deactivate

echo "> Creating input for autocorrelation"
        zcat ${NAME}.${WSIZE}.per-base.bed.gz | \
        awk -v alpha=$DELTA -v print_switch=0 \
        '{if (print_switch==1) {start=$2-alpha; if (start<0) {print $1"\t"0"\t"$3-alpha"\t"$4} else{print $1"\t"start"\t"$3-alpha"\t"$4}}
        else if (alpha >= $2 && alpha < $3) {start=$2-alpha;if (start<0) {print $1"\t"0"\t"$3-alpha"\t"$4} else {print $1"\t"start"\t"$3-alpha"\t"$4}; print_switch=1}}' | \
        gzip -c > ${NAME}.${WSIZE}.${DELTA}.bed.gz

        bedtools unionbedg -filler NA  \
        -i ${NAME}.${WSIZE}.per-base.bed.gz \
        ${NAME}.${WSIZE}.${DELTA}.bed.gz | \
        grep "$DIPLOID_REGEX" | \
        sort --parallel=$THREADS --version-sort -k4 -k5 | \
        awk  \
        '{if (FNR==1){diff=$3-$2;value1=$4;value2=$5}
        else if (value1!=$4 || value2!=$5){print value1"\t"value2"\t"diff; diff=$3-$2;value1=$4;value2=$5}
        else{diff=diff+($3-$2);value1=$4;value2=$5}
        }END{print value1"\t"value2"\t"diff}' \
        > ${NAME}.${DELTA}.shiftedcov.txt

echo "> Calculating gini and cv"
#if [[ ! -f ${NAME}.${WSIZE}.freqs.txt ]]
#then
        # Create a frequency table
        zcat ${NAME}.${WSIZE}.regions.bed.gz | \
        grep "$DIPLOID_REGEX" | \
        awk '{print $4}' | \
        sort -n | \
        uniq -c | \
        awk '{print $2"\t"$1}' | sort -n -k1,1 \
        > ${NAME}.${WSIZE}.freqs.txt
#fi

Rscript ${SCRIPTDIR}/src/GiniIndex.R ${NAME}.${WSIZE}
Rscript ${SCRIPTDIR}/src/CoefficientOfVariation.R ${NAME}.${WSIZE}

echo "> Calculating autocorrelation"

Rscript ${SCRIPTDIR}/src/Autocorrelation.R ${NAME}.${DELTA} $DELTA


echo "> Calculating MAD"

        # Paste values from consecutive windows together
        # I do not want to consider the counts from the last window because is shorter than the other
        # I should not use last comparison neither because it uses last window for one element. I have to only use the first column for calculating the average depth
        zcat ${NAME}.${WSIZE}.regions.bed.gz | \
                tail -n +2 | \
                paste  <(zcat ${NAME}.${WSIZE}.regions.bed.gz) - | \
                grep "$DIPLOID_REGEX" | \
                awk '{if (NF==8 && $1==$5) {print $4"\t"$8} else if (NF==8 && $1!=$5){print $4}}' | \
                sort | uniq -c | \
                awk '{if (NF==3) {print $2"\t"$3"\t"$1}else {print $2"\tNA\t"$1}}' \
                > ${NAME}.${WSIZE}.contiguous.txt


Rscript ${SCRIPTDIR}/src/MAD.R ${NAME}.${WSIZE}

rm ${NAME}.${DELTA}.shiftedcov.txt
rm ${NAME}.${WSIZE}.${DELTA}.bed.gz
rm ${NAME}.${WSIZE}.contiguous.txt
rm ${NAME}.${WSIZE}.freqs.txt
rm ${NAME}.${WSIZE}.regions.bed.gz
rm ${NAME}.${WSIZE}.regions.bed.gz.csi
rm ${NAME}.${WSIZE}.per-base.bed.gz
rm ${NAME}.${WSIZE}.per-base.bed.gz.csi


# ///// Run metaphyler only if the number of unmapped reads is high?
echo "> METAPHYLER"
samtools view -f 0x4 ${NAME}.bam | awk '{OFS="\t"; print ">"$1"\n"$10}' > ${NAME}.unmapped.fasta
~/apps/Metaphyler/MetaPhylerSRV0.115/metaphyler.pl 2 ${NAME}.unmapped.fasta ${NAME}

rm ${NAME}.unmapped.fasta
echo "> Finished!"

#
## Get the number of bases which are aligned, soft-clipped or unmapped (only count only primary aligments)
#aligned_soft_bases=$(samtools view -F 256 $WORKDIR/$SAMPLE.dedup.bam | cut -f10 | awk '{total+=length}END{print total}')
## Get the number of bases which are hard-clipped
# /// avoid counting secondary?
#hard_bases=$(samtools view $WORKDIR/$SAMPLE.dedup.bam | cut -f6 | grep H | sed 's/\([0-9]*\)\([A-Z]\)/\1\2\n/g' | grep -v "^$" | grep H | sed 's/H//' | awk '{sum+=$1}END{print sum}')
#if [ -z "$hard_bases" ];then
#	hard_bases=0
#fi
#raw_bases=$(($aligned_soft_bases + $hard_bases))
#genome_length=$(cat ${RESDIR}/${REF}.fai | cut -f2 | awk '{sum+=$1}END{print sum}')
#sequencing_depth=$(bc -l <<< "scale=4; $raw_bases / $genome_length")
#
## 1284: remove not primary alignments, unmapped and duplicates
#
#echo "> CREATE QC FILE"
#rm ${WORKDIR}/${SAMPLE}_QC.txt

# ////// index bam or require to be indexed
#samtools index ${NAME}.bam
#MT=$(samtools idxstats ${BAM} | grep -e "^MT" -e "^chrM" | awk '{print $3}')
#genome=$(cut -f 5 ${WORKDIR}/${SAMPLE}_genome.bed | head -1)
#breadth=$(head -1 ${WORKDIR}/${SAMPLE}_genome.bed | awk '{print (1-$5)*100}')
#class=$(awk '{if ($1 !~ "{") print $0}' ${WORKDIR}/${SAMPLE}.genus.tab | grep -v "^@" | awk '{if ($5 >= 98) print $1}' | tr -s '\n' ',' | sed 's/,$/\n/')
#
#awk -v sample=${SAMPLE} \
#	-v tbases=${raw_bases} \
#	-v seqdepth=${sequencing_depth} \
#	-v talign=${alignments} \
#	-v unique=${unique} -v \
#	unmapped=${unmapped} \
#	-v dup=${duplicate} \
#	-v mt=${MT} \
#	-v bact=${class} \
#	-v breadth=${breadth} \
#	-v genlen=${genome_length} \
#	-v adapt=${adapter} \
#	-v suppl=${chimeric} \
#	-v chimerapairs=${chimerapairs} \
#	-v preseq_inf=${preseq_inference} \
#	-F $'\t' 'BEGIN{OFS=FS; print sample,treads,tbases/1000000000,seqdepth,unique/treads*100,unmapped/treads*100,adapt,dup/(treads-unmapped)*100,chimeric/treads*100,chimerapairs,mt/(treads-unmapped)*100,bact,breadth,breadth*tbases/genlen,preseq_inf}' > ${WORKDIR}/${SAMPLE}_QC.txt

